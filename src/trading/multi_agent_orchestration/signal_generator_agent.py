#!/usr/bin/env python
# Cosmic Market Oracle - Signal Generator Agent

"""
Signal Generator Agent for the Multi-Agent Orchestration Network.

This module implements an agent that generates trading signals based on
astrological data, market data, and current market regime.
"""

import logging
import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta

from src.trading.multi_agent_orchestration.base import (
    AgentInterface, AgentMessage, MessageType
)
from src.astro_engine.astronomical_calculator import AstronomicalCalculator
from src.astro_engine.astrological_aspects import AspectCalculator, analyze_aspects_for_date

# Configure logging
logger = logging.getLogger(__name__)


class SignalGeneratorAgent(AgentInterface):
    """
    Agent for generating trading signals based on astrological data.
    
    This agent analyzes astrological data and market conditions to generate
    trading signals with associated confidence levels.
    """
    
    def __init__(self, agent_id: str, agent_type: str = "signal_generator",
                calculator: Optional[AstronomicalCalculator] = None,
                aspect_calculator: Optional[AspectCalculator] = None,
                confidence_threshold: float = 0.6):
        """
        Initialize the signal generator agent.
        
        Args:
            agent_id: Unique identifier for the agent
            agent_type: Type of agent (default: 'signal_generator')
            calculator: Astronomical calculator instance
            aspect_calculator: Aspect calculator instance
            confidence_threshold: Minimum confidence for signal generation
        """
        super().__init__(agent_id, agent_type)
        
        # Initialize calculators if not provided
        self.calculator = calculator or AstronomicalCalculator()
        self.aspect_calculator = aspect_calculator or AspectCalculator()
        
        self.confidence_threshold = confidence_threshold
        
        # State variables
        self.current_regime = "unknown"
        self.last_signal_time = None
        self.signal_history = []
        self.market_context = {}
        
        # Register specific message handlers
        self.message_handlers[MessageType.REGIME_CHANGE] = self._handle_regime_change
        self.message_handlers[MessageType.QUERY] = self._handle_query
        
    def _handle_regime_change(self, message: AgentMessage) -> Optional[AgentMessage]:
        """Handle regime change messages."""
        self.current_regime = message.content.get("new_regime", "unknown")
        logger.info(f"Agent {self.agent_id}: Updated current regime to {self.current_regime}")
        return None
        
    def _handle_query(self, message: AgentMessage) -> Optional[AgentMessage]:
        """Handle query messages."""
        query_type = message.content.get("query_type")
        
        if query_type == "last_signal":
            if not self.signal_history:
                return self.create_message(
                    message_type=MessageType.RESPONSE,
                    content={"query_type": query_type, "status": "no_signals"},
                    recipient_id=message.sender_id,
                    correlation_id=message.message_id
                )
                
            return self.create_message(
                message_type=MessageType.RESPONSE,
                content={
                    "query_type": query_type,
                    "last_signal": self.signal_history[-1]
                },
                recipient_id=message.sender_id,
                correlation_id=message.message_id
            )
            
        elif query_type == "signal_history":
            limit = message.content.get("limit", 10)
            return self.create_message(
                message_type=MessageType.RESPONSE,
                content={
                    "query_type": query_type,
                    "signal_history": self.signal_history[-limit:]
                },
                recipient_id=message.sender_id,
                correlation_id=message.message_id
            )
            
        return None
        
    def process(self, data: Dict[str, pd.DataFrame]) -> List[AgentMessage]:
        """
        Process data to generate trading signals.
        
        Args:
            data: Dictionary of data frames
            
        Returns:
            List of messages generated by the agent
        """
        messages = []
        
        # Check if required data is available
        if "market_data" not in data or "astrological_data" not in data:
            logger.warning(f"Agent {self.agent_id}: Missing required data")
            return messages
            
        market_data = data["market_data"]
        astro_data = data["astrological_data"]
        
        # Update market context
        self._update_market_context(market_data)
        
        # Generate signals based on astrological data
        signals = self._generate_signals(astro_data, market_data)
        
        # Filter signals by confidence threshold
        high_confidence_signals = [s for s in signals if s["confidence"] >= self.confidence_threshold]
        
        # Create messages for high-confidence signals
        for signal in high_confidence_signals:
            # Add to signal history
            self.signal_history.append(signal)
            if len(self.signal_history) > 100:
                self.signal_history = self.signal_history[-100:]
                
            # Create signal message
            messages.append(self.create_message(
                message_type=MessageType.SIGNAL,
                content=signal,
                priority=7  # High priority for signals
            ))
            
            logger.info(f"Agent {self.agent_id}: Generated {signal['signal_type']} signal "
                      f"with confidence {signal['confidence']:.2f}")
                      
        self.last_signal_time = datetime.now()
        
        return messages
        
    def _update_market_context(self, market_data: pd.DataFrame):
        """
        Update market context from market data.
        
        Args:
            market_data: Market data frame
        """
        if len(market_data) < 20:
            return
            
        recent_data = market_data.iloc[-20:]
        
        # Calculate basic market context
        returns = recent_data["close"].pct_change().dropna()
        
        self.market_context = {
            "current_price": recent_data["close"].iloc[-1],
            "daily_change": returns.iloc[-1] if len(returns) > 0 else 0,
            "volatility": returns.std(),
            "trend": "up" if returns.mean() > 0 else "down",
            "regime": self.current_regime
        }
        
    def _generate_signals(self, astro_data: pd.DataFrame, market_data: pd.DataFrame) -> List[Dict[str, Any]]:
        """
        Generate trading signals based on astrological data.
        
        Args:
            astro_data: Astrological data frame
            market_data: Market data frame
            
        Returns:
            List of signal dictionaries
        """
        signals = []
        
        # Get current date or last date in data
        current_date = datetime.now().date()
        if "date" in astro_data.columns:
            last_date = pd.to_datetime(astro_data["date"].iloc[-1]).date()
            current_date = min(current_date, last_date)
            
        # Analyze aspects for the current date
        try:
            aspects = analyze_aspects_for_date(
                self.aspect_calculator, 
                current_date, 
                orb=2.0  # Tighter orb for signal generation
            )
        except Exception as e:
            logger.error(f"Agent {self.agent_id}: Error analyzing aspects: {e}")
            aspects = []
            
        # Generate signals based on aspects
        for aspect in aspects:
            signal = self._aspect_to_signal(aspect)
            if signal:
                signals.append(signal)
                
        # Adjust confidence based on market regime
        for signal in signals:
            self._adjust_confidence_for_regime(signal)
            
        return signals
        
    def _aspect_to_signal(self, aspect: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Convert an astrological aspect to a trading signal.
        
        Args:
            aspect: Aspect dictionary
            
        Returns:
            Signal dictionary or None
        """
        # Extract aspect information
        planet1 = aspect.get("planet1")
        planet2 = aspect.get("planet2")
        aspect_type = aspect.get("aspect_type")
        aspect_angle = aspect.get("angle")
        exact = aspect.get("exact", False)
        
        # Skip aspects that aren't relevant for trading
        if not planet1 or not planet2 or not aspect_type:
            return None
            
        # Initialize signal
        signal = {
            "timestamp": datetime.now().isoformat(),
            "source": f"{planet1}-{planet2} {aspect_type}",
            "signal_type": "neutral",
            "confidence": 0.5,
            "horizon": "medium",  # short, medium, long
            "aspect": aspect
        }
        
        # Determine signal type based on aspect
        if aspect_type == "conjunction":
            if planet1 == "Jupiter" or planet2 == "Jupiter":
                signal["signal_type"] = "bullish"
                signal["confidence"] = 0.7 if exact else 0.6
            elif planet1 == "Saturn" or planet2 == "Saturn":
                signal["signal_type"] = "bearish"
                signal["confidence"] = 0.7 if exact else 0.6
                
        elif aspect_type == "opposition":
            if (planet1 == "Mars" and planet2 == "Saturn") or (planet1 == "Saturn" and planet2 == "Mars"):
                signal["signal_type"] = "bearish"
                signal["confidence"] = 0.8 if exact else 0.7
                signal["horizon"] = "short"
                
        elif aspect_type == "trine":
            if (planet1 == "Sun" and planet2 == "Jupiter") or (planet1 == "Jupiter" and planet2 == "Sun"):
                signal["signal_type"] = "bullish"
                signal["confidence"] = 0.75 if exact else 0.65
                
        elif aspect_type == "square":
            if (planet1 == "Mars" and planet2 == "Uranus") or (planet1 == "Uranus" and planet2 == "Mars"):
                signal["signal_type"] = "volatile"
                signal["confidence"] = 0.8 if exact else 0.7
                signal["horizon"] = "short"
                
        # Add additional context
        signal["description"] = f"{planet1}-{planet2} {aspect_type} indicates {signal['signal_type']} conditions"
        signal["action"] = "buy" if signal["signal_type"] == "bullish" else (
            "sell" if signal["signal_type"] == "bearish" else "hold"
        )
        
        return signal
        
    def _adjust_confidence_for_regime(self, signal: Dict[str, Any]):
        """
        Adjust signal confidence based on current market regime.
        
        Args:
            signal: Signal dictionary to adjust
        """
        # Adjust confidence based on regime
        if self.current_regime == "bull":
            if signal["signal_type"] == "bullish":
                signal["confidence"] = min(0.95, signal["confidence"] * 1.2)
            elif signal["signal_type"] == "bearish":
                signal["confidence"] = max(0.3, signal["confidence"] * 0.8)
                
        elif self.current_regime == "bear":
            if signal["signal_type"] == "bearish":
                signal["confidence"] = min(0.95, signal["confidence"] * 1.2)
            elif signal["signal_type"] == "bullish":
                signal["confidence"] = max(0.3, signal["confidence"] * 0.8)
                
        elif self.current_regime == "volatile":
            if signal["signal_type"] == "volatile":
                signal["confidence"] = min(0.95, signal["confidence"] * 1.3)
                
        # Add regime information to signal
        signal["market_regime"] = self.current_regime
