#!/usr/bin/env python
# Cosmic Market Oracle - Multi-Agent Orchestration Network Base

"""
Base components for the Multi-Agent Orchestration Network.

This module defines the core interfaces and components for the multi-agent system,
including the agent interface, message passing system, and agent registry.
"""

import uuid
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Any, Optional, Set, Callable, Union, Type
import logging
import json
import pandas as pd
import numpy as np

# Configure logging
logger = logging.getLogger(__name__)


class MessageType(Enum):
    """Types of messages that can be exchanged between agents."""
    MARKET_DATA = "market_data"
    ASTROLOGICAL_DATA = "astrological_data"
    PREDICTION = "prediction"
    REGIME_CHANGE = "regime_change"
    SIGNAL = "signal"
    RISK_ALERT = "risk_alert"
    QUERY = "query"
    RESPONSE = "response"
    COMMAND = "command"
    STATUS = "status"
    ERROR = "error"


@dataclass
class AgentMessage:
    """Message exchanged between agents in the multi-agent system."""
    message_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    sender_id: str = ""
    recipient_id: Optional[str] = None  # None for broadcast
    message_type: MessageType = MessageType.STATUS
    content: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: Optional[str] = None  # For linking related messages
    priority: int = 1  # 1 (lowest) to 10 (highest)
    ttl: int = 10  # Time-to-live for message hops
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert message to dictionary for serialization."""
        return {
            "message_id": self.message_id,
            "sender_id": self.sender_id,
            "recipient_id": self.recipient_id,
            "message_type": self.message_type.value,
            "content": self.content,
            "timestamp": self.timestamp.isoformat(),
            "correlation_id": self.correlation_id,
            "priority": self.priority,
            "ttl": self.ttl
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AgentMessage':
        """Create message from dictionary."""
        # Convert string message_type back to enum
        data["message_type"] = MessageType(data["message_type"])
        
        # Convert timestamp string back to datetime
        if isinstance(data["timestamp"], str):
            data["timestamp"] = datetime.fromisoformat(data["timestamp"])
            
        return cls(**data)


class AgentInterface(ABC):
    """Interface that all agents in the multi-agent system must implement."""
    
    def __init__(self, agent_id: str, agent_type: str):
        """
        Initialize the agent.
        
        Args:
            agent_id: Unique identifier for the agent
            agent_type: Type of agent (e.g., 'market_regime', 'signal_generator')
        """
        self.agent_id = agent_id
        self.agent_type = agent_type
        self.message_handlers: Dict[MessageType, Callable] = {}
        self._register_handlers()
        
    def _register_handlers(self):
        """Register message handlers for different message types."""
        # Register default handler for all message types
        for message_type in MessageType:
            self.message_handlers[message_type] = self._default_handler
            
    def _default_handler(self, message: AgentMessage) -> Optional[AgentMessage]:
        """Default message handler."""
        logger.debug(f"Agent {self.agent_id} received unhandled message: {message.message_type}")
        return None
    
    def handle_message(self, message: AgentMessage) -> Optional[AgentMessage]:
        """
        Handle an incoming message.
        
        Args:
            message: The message to handle
            
        Returns:
            Optional response message
        """
        if message.ttl <= 0:
            logger.warning(f"Message {message.message_id} TTL expired, dropping")
            return None
            
        handler = self.message_handlers.get(message.message_type, self._default_handler)
        return handler(message)
    
    @abstractmethod
    def process(self, data: Dict[str, pd.DataFrame]) -> List[AgentMessage]:
        """
        Process data and generate messages.
        
        Args:
            data: Dictionary of data frames (market data, astrological data, etc.)
            
        Returns:
            List of messages generated by the agent
        """
        pass
    
    def create_message(
        self, 
        message_type: MessageType,
        content: Dict[str, Any],
        recipient_id: Optional[str] = None,
        correlation_id: Optional[str] = None,
        priority: int = 1
    ) -> AgentMessage:
        """
        Create a new message.
        
        Args:
            message_type: Type of message
            content: Message content
            recipient_id: Recipient ID (None for broadcast)
            correlation_id: Correlation ID for linking related messages
            priority: Message priority (1-10)
            
        Returns:
            New message
        """
        return AgentMessage(
            sender_id=self.agent_id,
            recipient_id=recipient_id,
            message_type=message_type,
            content=content,
            correlation_id=correlation_id,
            priority=priority
        )


class MessageBroker:
    """Broker for passing messages between agents."""
    
    def __init__(self):
        """Initialize the message broker."""
        self.subscriptions: Dict[MessageType, Set[str]] = {
            message_type: set() for message_type in MessageType
        }
        self.agents: Dict[str, AgentInterface] = {}
        self.message_history: List[AgentMessage] = []
        self.max_history_size = 1000
        
    def register_agent(self, agent: AgentInterface):
        """
        Register an agent with the broker.
        
        Args:
            agent: The agent to register
        """
        self.agents[agent.agent_id] = agent
        
    def subscribe(self, agent_id: str, message_types: List[MessageType]):
        """
        Subscribe an agent to message types.
        
        Args:
            agent_id: ID of the agent
            message_types: Message types to subscribe to
        """
        for message_type in message_types:
            self.subscriptions[message_type].add(agent_id)
            
    def unsubscribe(self, agent_id: str, message_types: List[MessageType]):
        """
        Unsubscribe an agent from message types.
        
        Args:
            agent_id: ID of the agent
            message_types: Message types to unsubscribe from
        """
        for message_type in message_types:
            if agent_id in self.subscriptions[message_type]:
                self.subscriptions[message_type].remove(agent_id)
                
    def publish(self, message: AgentMessage) -> List[AgentMessage]:
        """
        Publish a message to subscribers.
        
        Args:
            message: The message to publish
            
        Returns:
            List of response messages
        """
        # Decrement TTL
        message.ttl -= 1
        if message.ttl <= 0:
            logger.warning(f"Message {message.message_id} TTL expired, dropping")
            return []
            
        # Add to history
        self.message_history.append(message)
        if len(self.message_history) > self.max_history_size:
            self.message_history = self.message_history[-self.max_history_size:]
            
        responses = []
        
        # Direct message
        if message.recipient_id is not None:
            if message.recipient_id in self.agents:
                response = self.agents[message.recipient_id].handle_message(message)
                if response:
                    responses.append(response)
            else:
                logger.warning(f"Recipient agent {message.recipient_id} not found")
                
        # Broadcast message
        else:
            subscribers = self.subscriptions[message.message_type]
            for agent_id in subscribers:
                if agent_id != message.sender_id and agent_id in self.agents:
                    response = self.agents[agent_id].handle_message(message)
                    if response:
                        responses.append(response)
                        
        return responses


class AgentRegistry:
    """Registry for managing agent creation and configuration."""
    
    def __init__(self):
        """Initialize the agent registry."""
        self.agent_types: Dict[str, Type[AgentInterface]] = {}
        self.agent_configs: Dict[str, Dict[str, Any]] = {}
        
    def register_agent_type(self, agent_type: str, agent_class: Type[AgentInterface]):
        """
        Register an agent type.
        
        Args:
            agent_type: Type identifier
            agent_class: Agent class
        """
        self.agent_types[agent_type] = agent_class
        
    def create_agent(self, agent_type: str, agent_id: str, **kwargs) -> AgentInterface:
        """
        Create an agent of the specified type.
        
        Args:
            agent_type: Type of agent to create
            agent_id: ID for the new agent
            **kwargs: Additional arguments for agent initialization
            
        Returns:
            New agent instance
        """
        if agent_type not in self.agent_types:
            raise ValueError(f"Unknown agent type: {agent_type}")
            
        agent_class = self.agent_types[agent_type]
        return agent_class(agent_id=agent_id, agent_type=agent_type, **kwargs)
        
    def save_config(self, config_file: str):
        """
        Save agent configurations to file.
        
        Args:
            config_file: Path to configuration file
        """
        with open(config_file, 'w') as f:
            json.dump(self.agent_configs, f, indent=2)
            
    def load_config(self, config_file: str):
        """
        Load agent configurations from file.
        
        Args:
            config_file: Path to configuration file
        """
        with open(config_file, 'r') as f:
            self.agent_configs = json.load(f)
