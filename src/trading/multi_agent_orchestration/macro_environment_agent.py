#!/usr/bin/env python
# Cosmic Market Oracle - Macro Environment Agent

"""
Macro Environment Agent for the Multi-Agent Orchestration Network.

This module implements an agent that analyzes macroeconomic factors and their
correlation with astrological data to provide broader market context.
"""

import logging
import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta

from src.trading.multi_agent_orchestration.base import (
    AgentInterface, AgentMessage, MessageType
)

# Configure logging
logger = logging.getLogger(__name__)


class MacroEnvironmentAgent(AgentInterface):
    """
    Agent for analyzing macroeconomic factors and their astrological correlations.
    
    This agent monitors broader economic indicators and their relationship with
    astrological factors to provide context for market predictions.
    """
    
    def __init__(self, agent_id: str, agent_type: str = "macro_environment",
                update_frequency: int = 7,  # days
                correlation_threshold: float = 0.3):
        """
        Initialize the macro environment agent.
        
        Args:
            agent_id: Unique identifier for the agent
            agent_type: Type of agent (default: 'macro_environment')
            update_frequency: Frequency of macro updates in days
            correlation_threshold: Threshold for significant correlations
        """
        super().__init__(agent_id, agent_type)
        
        self.update_frequency = update_frequency
        self.correlation_threshold = correlation_threshold
        
        # State variables
        self.macro_indicators = {}
        self.astro_correlations = {}
        self.last_update_time = None
        self.macro_trends = {}
        
        # Register specific message handlers
        self.message_handlers[MessageType.QUERY] = self._handle_query
        
    def _handle_query(self, message: AgentMessage) -> Optional[AgentMessage]:
        """Handle query messages."""
        query_type = message.content.get("query_type")
        
        if query_type == "macro_indicators":
            return self.create_message(
                message_type=MessageType.RESPONSE,
                content={
                    "query_type": query_type,
                    "macro_indicators": self.macro_indicators,
                    "last_update": self.last_update_time.isoformat() if self.last_update_time else None
                },
                recipient_id=message.sender_id,
                correlation_id=message.message_id
            )
            
        elif query_type == "astro_correlations":
            return self.create_message(
                message_type=MessageType.RESPONSE,
                content={
                    "query_type": query_type,
                    "astro_correlations": self.astro_correlations
                },
                recipient_id=message.sender_id,
                correlation_id=message.message_id
            )
            
        elif query_type == "macro_trends":
            return self.create_message(
                message_type=MessageType.RESPONSE,
                content={
                    "query_type": query_type,
                    "macro_trends": self.macro_trends
                },
                recipient_id=message.sender_id,
                correlation_id=message.message_id
            )
            
        return None
        
    def process(self, data: Dict[str, pd.DataFrame]) -> List[AgentMessage]:
        """
        Process data to analyze macroeconomic factors.
        
        Args:
            data: Dictionary of data frames
            
        Returns:
            List of messages generated by the agent
        """
        messages = []
        
        # Check if we need to update macro analysis
        now = datetime.now()
        if (self.last_update_time is None or 
            (now - self.last_update_time).days >= self.update_frequency):
            
            # Check if required data is available
            if "macro_data" not in data:
                logger.warning(f"Agent {self.agent_id}: No macro data available")
                return messages
                
            macro_data = data["macro_data"]
            
            # Update macro indicators
            self._update_macro_indicators(macro_data)
            
            # Analyze correlations with astrological data if available
            if "astrological_data" in data:
                self._analyze_astro_correlations(macro_data, data["astrological_data"])
                
            # Update macro trends
            self._update_macro_trends(macro_data)
            
            # Create message with macro update
            messages.append(self.create_message(
                message_type=MessageType.STATUS,
                content={
                    "update_type": "macro_environment",
                    "macro_indicators": {k: v["value"] for k, v in self.macro_indicators.items()},
                    "macro_trends": self.macro_trends,
                    "significant_correlations": [
                        {"macro": k, "astro": v["astro_factor"], "correlation": v["correlation"]}
                        for k, v in self.astro_correlations.items()
                        if abs(v["correlation"]) >= self.correlation_threshold
                    ]
                },
                priority=5  # Medium priority
            ))
            
            self.last_update_time = now
            
            logger.info(f"Agent {self.agent_id}: Updated macro environment analysis")
            
        return messages
        
    def _update_macro_indicators(self, macro_data: pd.DataFrame):
        """
        Update macroeconomic indicators from data.
        
        Args:
            macro_data: Macroeconomic data frame
        """
        # Extract the latest values for key indicators
        latest_data = macro_data.iloc[-1] if not macro_data.empty else pd.Series()
        
        # Define indicators to track
        indicators = [
            "gdp_growth", "inflation", "unemployment", "interest_rate", 
            "consumer_confidence", "manufacturing_pmi", "retail_sales",
            "housing_starts", "industrial_production"
        ]
        
        # Update indicators that are present in the data
        for indicator in indicators:
            if indicator in latest_data:
                value = latest_data[indicator]
                
                # Calculate z-score if we have historical data
                z_score = None
                if len(macro_data) > 30 and indicator in macro_data.columns:
                    history = macro_data[indicator].dropna()
                    if len(history) > 0:
                        mean = history.mean()
                        std = history.std()
                        if std > 0:
                            z_score = (value - mean) / std
                
                # Determine trend
                trend = "neutral"
                if len(macro_data) > 2 and indicator in macro_data.columns:
                    prev_value = macro_data[indicator].iloc[-2]
                    if value > prev_value * 1.01:
                        trend = "improving"
                    elif value < prev_value * 0.99:
                        trend = "deteriorating"
                
                # Store indicator data
                self.macro_indicators[indicator] = {
                    "value": value,
                    "z_score": z_score,
                    "trend": trend,
                    "last_update": datetime.now().isoformat()
                }
        
    def _analyze_astro_correlations(self, macro_data: pd.DataFrame, astro_data: pd.DataFrame):
        """
        Analyze correlations between macro indicators and astrological factors.
        
        Args:
            macro_data: Macroeconomic data frame
            astro_data: Astrological data frame
        """
        # Ensure we have enough data
        if len(macro_data) < 30 or len(astro_data) < 30:
            logger.warning(f"Agent {self.agent_id}: Insufficient data for correlation analysis")
            return
        
        # Align data by date
        if "date" in macro_data.columns and "date" in astro_data.columns:
            macro_data = macro_data.set_index("date")
            astro_data = astro_data.set_index("date")
            
            # Resample to ensure consistent frequency
            macro_data = macro_data.resample("D").ffill()
            astro_data = astro_data.resample("D").ffill()
            
            # Align indices
            common_dates = macro_data.index.intersection(astro_data.index)
            if len(common_dates) < 30:
                logger.warning(f"Agent {self.agent_id}: Insufficient overlapping data for correlation analysis")
                return
                
            macro_aligned = macro_data.loc[common_dates]
            astro_aligned = astro_data.loc[common_dates]
            
            # Calculate correlations
            for macro_col in macro_aligned.columns:
                if macro_col in self.macro_indicators:
                    for astro_col in astro_aligned.columns:
                        if astro_col.startswith("planet_") or astro_col.startswith("aspect_"):
                            # Calculate correlation
                            correlation = macro_aligned[macro_col].corr(astro_aligned[astro_col])
                            
                            # Store if significant
                            if abs(correlation) >= self.correlation_threshold:
                                self.astro_correlations[f"{macro_col}_{astro_col}"] = {
                                    "macro_factor": macro_col,
                                    "astro_factor": astro_col,
                                    "correlation": correlation,
                                    "last_update": datetime.now().isoformat()
                                }
        
    def _update_macro_trends(self, macro_data: pd.DataFrame):
        """
        Update macroeconomic trends from data.
        
        Args:
            macro_data: Macroeconomic data frame
        """
        # Ensure we have enough data
        if len(macro_data) < 60:
            logger.warning(f"Agent {self.agent_id}: Insufficient data for trend analysis")
            return
            
        # Calculate economic cycle indicators
        if "gdp_growth" in macro_data.columns:
            gdp_growth = macro_data["gdp_growth"].rolling(4).mean()
            if not gdp_growth.empty:
                latest_growth = gdp_growth.iloc[-1]
                prev_growth = gdp_growth.iloc[-5] if len(gdp_growth) >= 5 else 0
                
                if latest_growth > 3.0:
                    cycle_phase = "expansion"
                elif latest_growth > 0:
                    cycle_phase = "recovery" if latest_growth > prev_growth else "slowdown"
                else:
                    cycle_phase = "recession"
                    
                self.macro_trends["economic_cycle"] = {
                    "phase": cycle_phase,
                    "growth_rate": latest_growth,
                    "momentum": "accelerating" if latest_growth > prev_growth else "decelerating"
                }
                
        # Calculate inflation trend
        if "inflation" in macro_data.columns:
            inflation = macro_data["inflation"].rolling(3).mean()
            if not inflation.empty:
                latest_inflation = inflation.iloc[-1]
                prev_inflation = inflation.iloc[-4] if len(inflation) >= 4 else 0
                
                self.macro_trends["inflation"] = {
                    "level": "high" if latest_inflation > 4.0 else 
                             ("moderate" if latest_inflation > 2.0 else "low"),
                    "trend": "rising" if latest_inflation > prev_inflation else "falling",
                    "value": latest_inflation
                }
                
        # Calculate monetary policy stance
        if "interest_rate" in macro_data.columns:
            interest_rate = macro_data["interest_rate"]
            if not interest_rate.empty:
                latest_rate = interest_rate.iloc[-1]
                prev_rate = interest_rate.iloc[-2] if len(interest_rate) >= 2 else latest_rate
                
                if latest_rate > prev_rate:
                    policy_stance = "tightening"
                elif latest_rate < prev_rate:
                    policy_stance = "easing"
                else:
                    policy_stance = "neutral"
                    
                self.macro_trends["monetary_policy"] = {
                    "stance": policy_stance,
                    "rate": latest_rate,
                    "real_rate": latest_rate - self.macro_trends.get("inflation", {}).get("value", 2.0)
                }
                
        # Calculate overall economic health
        health_score = 0
        health_factors = 0
        
        for indicator, data in self.macro_indicators.items():
            if indicator == "gdp_growth" and "value" in data:
                health_score += min(5, max(0, data["value"] + 2)) / 5 * 3
                health_factors += 3
            elif indicator == "unemployment" and "value" in data:
                health_score += (10 - min(10, max(0, data["value"]))) / 10 * 2
                health_factors += 2
            elif indicator == "consumer_confidence" and "value" in data:
                health_score += min(100, max(0, data["value"])) / 100 * 2
                health_factors += 2
            elif indicator == "manufacturing_pmi" and "value" in data:
                health_score += (min(60, max(30, data["value"])) - 30) / 30 * 2
                health_factors += 2
                
        if health_factors > 0:
            health_rating = health_score / health_factors
            
            self.macro_trends["economic_health"] = {
                "score": health_rating,
                "rating": "excellent" if health_rating > 0.8 else
                          ("good" if health_rating > 0.6 else
                           ("fair" if health_rating > 0.4 else "poor")),
                "contributing_factors": health_factors
            }
