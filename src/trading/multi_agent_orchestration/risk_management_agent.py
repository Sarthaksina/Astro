#!/usr/bin/env python
# Cosmic Market Oracle - Risk Management Agent

"""
Risk Management Agent for the Multi-Agent Orchestration Network.

This module implements an agent that monitors risk factors and generates
risk alerts based on market conditions and astrological data.
"""

import logging
import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta

from src.trading.multi_agent_orchestration.base import (
    AgentInterface, AgentMessage, MessageType
)

# Configure logging
logger = logging.getLogger(__name__)


class RiskManagementAgent(AgentInterface):
    """
    Agent for monitoring and managing risk factors.
    
    This agent analyzes market data and astrological factors to identify
    potential risks and generate risk alerts with mitigation strategies.
    """
    
    def __init__(self, agent_id: str, agent_type: str = "risk_management",
                max_risk_tolerance: float = 0.7,
                volatility_threshold: float = 0.02,
                drawdown_threshold: float = 0.05):
        """
        Initialize the risk management agent.
        
        Args:
            agent_id: Unique identifier for the agent
            agent_type: Type of agent (default: 'risk_management')
            max_risk_tolerance: Maximum acceptable risk level (0-1)
            volatility_threshold: Threshold for high volatility alert
            drawdown_threshold: Threshold for drawdown alert
        """
        super().__init__(agent_id, agent_type)
        
        self.max_risk_tolerance = max_risk_tolerance
        self.volatility_threshold = volatility_threshold
        self.drawdown_threshold = drawdown_threshold
        
        # State variables
        self.current_risk_level = 0.5  # Default medium risk
        self.risk_factors = {}
        self.alert_history = []
        self.last_alert_time = None
        
        # Register specific message handlers
        self.message_handlers[MessageType.REGIME_CHANGE] = self._handle_regime_change
        self.message_handlers[MessageType.QUERY] = self._handle_query
        
    def _handle_regime_change(self, message: AgentMessage) -> Optional[AgentMessage]:
        """Handle regime change messages."""
        new_regime = message.content.get("new_regime", "unknown")
        
        # Update risk level based on regime
        if new_regime == "bull":
            self.current_risk_level = max(0.3, self.current_risk_level * 0.8)
        elif new_regime == "bear":
            self.current_risk_level = min(0.8, self.current_risk_level * 1.3)
        elif new_regime == "volatile":
            self.current_risk_level = min(0.9, self.current_risk_level * 1.5)
            
        logger.info(f"Agent {self.agent_id}: Updated risk level to {self.current_risk_level:.2f} "
                  f"based on regime change to {new_regime}")
                  
        return None
        
    def _handle_query(self, message: AgentMessage) -> Optional[AgentMessage]:
        """Handle query messages."""
        query_type = message.content.get("query_type")
        
        if query_type == "current_risk":
            return self.create_message(
                message_type=MessageType.RESPONSE,
                content={
                    "query_type": query_type,
                    "current_risk_level": self.current_risk_level,
                    "risk_factors": self.risk_factors
                },
                recipient_id=message.sender_id,
                correlation_id=message.message_id
            )
            
        elif query_type == "alert_history":
            limit = message.content.get("limit", 10)
            return self.create_message(
                message_type=MessageType.RESPONSE,
                content={
                    "query_type": query_type,
                    "alert_history": self.alert_history[-limit:]
                },
                recipient_id=message.sender_id,
                correlation_id=message.message_id
            )
            
        return None
        
    def process(self, data: Dict[str, pd.DataFrame]) -> List[AgentMessage]:
        """
        Process data to monitor risk factors and generate alerts.
        
        Args:
            data: Dictionary of data frames
            
        Returns:
            List of messages generated by the agent
        """
        messages = []
        
        # Check if market data is available
        if "market_data" not in data:
            logger.warning(f"Agent {self.agent_id}: No market data available")
            return messages
            
        market_data = data["market_data"]
        
        # Ensure we have enough data
        if len(market_data) < 30:
            logger.warning(f"Agent {self.agent_id}: Insufficient data for risk assessment")
            return messages
            
        # Assess risk factors
        risk_factors = self._assess_risk_factors(market_data, data.get("astrological_data"))
        
        # Update risk level
        self._update_risk_level(risk_factors)
        
        # Generate alerts for high-risk factors
        alerts = self._generate_risk_alerts(risk_factors)
        
        # Create messages for alerts
        for alert in alerts:
            # Add to alert history
            self.alert_history.append(alert)
            if len(self.alert_history) > 100:
                self.alert_history = self.alert_history[-100:]
                
            # Create alert message
            messages.append(self.create_message(
                message_type=MessageType.RISK_ALERT,
                content=alert,
                priority=9  # Very high priority for risk alerts
            ))
            
            logger.info(f"Agent {self.agent_id}: Generated {alert['alert_type']} risk alert "
                      f"with severity {alert['severity']:.2f}")
                      
        self.last_alert_time = datetime.now()
        
        return messages
        
    def _assess_risk_factors(self, market_data: pd.DataFrame, 
                           astro_data: Optional[pd.DataFrame] = None) -> Dict[str, Dict[str, Any]]:
        """
        Assess various risk factors from market and astrological data.
        
        Args:
            market_data: Market data frame
            astro_data: Astrological data frame (optional)
            
        Returns:
            Dictionary of risk factors
        """
        risk_factors = {}
        
        # Calculate market-based risk factors
        recent_data = market_data.iloc[-30:]
        returns = recent_data["close"].pct_change().dropna()
        
        # Volatility risk
        volatility = returns.std()
        volatility_risk = min(1.0, volatility / self.volatility_threshold)
        risk_factors["volatility"] = {
            "value": volatility,
            "risk_level": volatility_risk,
            "description": f"Market volatility ({volatility:.4f})"
        }
        
        # Drawdown risk
        peak = recent_data["close"].max()
        current = recent_data["close"].iloc[-1]
        drawdown = (current - peak) / peak
        drawdown_risk = min(1.0, abs(drawdown) / self.drawdown_threshold)
        
        risk_factors["drawdown"] = {
            "value": drawdown,
            "risk_level": drawdown_risk,
            "description": f"Market drawdown ({drawdown:.4f})"
        }
        
        # Trend reversal risk
        short_ma = recent_data["close"].rolling(5).mean().iloc[-1]
        long_ma = recent_data["close"].rolling(20).mean().iloc[-1]
        
        if short_ma > long_ma and short_ma / long_ma < 1.01:
            trend_risk = 0.7  # Potential bullish trend weakening
        elif short_ma < long_ma and short_ma / long_ma > 0.99:
            trend_risk = 0.7  # Potential bearish trend weakening
        else:
            trend_risk = 0.3  # Stable trend
            
        risk_factors["trend_reversal"] = {
            "value": short_ma / long_ma,
            "risk_level": trend_risk,
            "description": f"Trend reversal potential ({short_ma/long_ma:.4f})"
        }
        
        # Volume anomaly risk
        if "volume" in recent_data.columns:
            avg_volume = recent_data["volume"].mean()
            recent_volume = recent_data["volume"].iloc[-1]
            volume_ratio = recent_volume / avg_volume
            
            volume_risk = 0.0
            if volume_ratio > 2.0:
                volume_risk = 0.8  # Unusually high volume
            elif volume_ratio < 0.5:
                volume_risk = 0.6  # Unusually low volume
                
            risk_factors["volume_anomaly"] = {
                "value": volume_ratio,
                "risk_level": volume_risk,
                "description": f"Volume anomaly ({volume_ratio:.2f}x normal)"
            }
            
        # Astrological risk factors (if data available)
        if astro_data is not None and not astro_data.empty:
            # Add astrological risk factors here
            # This would typically involve analyzing planetary aspects
            # that are historically associated with market volatility
            pass
            
        # Store risk factors
        self.risk_factors = risk_factors
        
        return risk_factors
        
    def _update_risk_level(self, risk_factors: Dict[str, Dict[str, Any]]):
        """
        Update the current risk level based on risk factors.
        
        Args:
            risk_factors: Dictionary of risk factors
        """
        # Calculate weighted average of risk factors
        total_risk = 0.0
        total_weight = 0.0
        
        weights = {
            "volatility": 0.4,
            "drawdown": 0.3,
            "trend_reversal": 0.2,
            "volume_anomaly": 0.1
        }
        
        for factor, data in risk_factors.items():
            weight = weights.get(factor, 0.1)
            total_risk += data["risk_level"] * weight
            total_weight += weight
            
        if total_weight > 0:
            new_risk_level = total_risk / total_weight
            
            # Smooth risk level changes
            self.current_risk_level = 0.7 * self.current_risk_level + 0.3 * new_risk_level
            
    def _generate_risk_alerts(self, risk_factors: Dict[str, Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Generate risk alerts based on risk factors.
        
        Args:
            risk_factors: Dictionary of risk factors
            
        Returns:
            List of risk alert dictionaries
        """
        alerts = []
        
        # Check each risk factor for alert conditions
        for factor, data in risk_factors.items():
            risk_level = data["risk_level"]
            
            # Generate alert if risk level exceeds threshold
            if risk_level >= 0.7:
                severity = min(1.0, risk_level)
                
                alert = {
                    "timestamp": datetime.now().isoformat(),
                    "alert_type": factor,
                    "severity": severity,
                    "description": data["description"],
                    "risk_level": self.current_risk_level,
                    "mitigation": self._get_mitigation_strategy(factor, severity)
                }
                
                alerts.append(alert)
                
        # Generate overall risk alert if current risk level is too high
        if self.current_risk_level > self.max_risk_tolerance:
            alert = {
                "timestamp": datetime.now().isoformat(),
                "alert_type": "overall_risk",
                "severity": self.current_risk_level,
                "description": f"Overall risk level ({self.current_risk_level:.2f}) exceeds tolerance",
                "risk_level": self.current_risk_level,
                "mitigation": "Consider reducing position sizes and implementing tighter stop losses"
            }
            
            alerts.append(alert)
            
        return alerts
        
    def _get_mitigation_strategy(self, risk_factor: str, severity: float) -> str:
        """
        Get a mitigation strategy for a specific risk factor.
        
        Args:
            risk_factor: Type of risk factor
            severity: Severity of the risk (0-1)
            
        Returns:
            Mitigation strategy description
        """
        if risk_factor == "volatility":
            if severity > 0.8:
                return "Reduce position sizes by 50% and widen stop losses to avoid whipsaws"
            else:
                return "Consider using options strategies to hedge against volatility"
                
        elif risk_factor == "drawdown":
            if severity > 0.8:
                return "Implement trailing stop losses and consider partial profit taking"
            else:
                return "Review stop loss levels and consider hedging with inverse ETFs"
                
        elif risk_factor == "trend_reversal":
            return "Prepare for potential trend change by reducing position sizes and tightening stops"
            
        elif risk_factor == "volume_anomaly":
            return "Monitor price action closely as unusual volume often precedes significant moves"
            
        else:
            return "Implement general risk management measures including position size reduction"
