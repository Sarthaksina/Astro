# Cosmic Market Oracle - Database Models

from sqlalchemy import Column, Integer, Float, String, DateTime, Boolean, ForeignKey, Index
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
import datetime

# Import Base from database configuration
from config.database import Base


class MarketData(Base):
    """Time series market data model for storing historical market information"""
    __tablename__ = "market_data"
    
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    symbol = Column(String, nullable=False, index=True)
    open = Column(Float, nullable=False)
    high = Column(Float, nullable=False)
    low = Column(Float, nullable=False)
    close = Column(Float, nullable=False)
    volume = Column(Float, nullable=True)
    adjusted_close = Column(Float, nullable=True)
    
    # Additional market metrics
    volatility = Column(Float, nullable=True)
    rsi = Column(Float, nullable=True)  # Relative Strength Index
    macd = Column(Float, nullable=True)  # Moving Average Convergence Divergence
    
    # Create a composite index for efficient time-based queries
    __table_args__ = (
        Index('idx_market_data_time_symbol', 'timestamp', 'symbol'),
    )
    
    def __repr__(self):
        return f"<MarketData(timestamp='{self.timestamp}', symbol='{self.symbol}', close={self.close})>"


class PlanetaryData(Base):
    """Time series planetary position data model"""
    __tablename__ = "planetary_data"
    
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    planet_id = Column(Integer, nullable=False, index=True)  # Swiss Ephemeris planet ID
    planet_name = Column(String, nullable=False)
    longitude = Column(Float, nullable=False)  # Zodiacal longitude (0-360 degrees)
    latitude = Column(Float, nullable=False)  # Celestial latitude
    distance = Column(Float, nullable=False)  # Distance from Earth in AU
    longitude_speed = Column(Float, nullable=False)  # Speed in longitude (degrees/day)
    is_retrograde = Column(Boolean, nullable=False)  # True if planet is retrograde
    nakshatra = Column(Integer, nullable=False)  # Nakshatra (1-27)
    nakshatra_degree = Column(Float, nullable=False)  # Degree within nakshatra
    
    # Create a composite index for efficient time-based queries
    __table_args__ = (
        Index('idx_planetary_data_time_planet', 'timestamp', 'planet_id'),
    )
    
    def __repr__(self):
        return f"<PlanetaryData(timestamp='{self.timestamp}', planet='{self.planet_name}', longitude={self.longitude})>"


class PlanetaryAspect(Base):
    """Planetary aspect data model for storing relationships between planets"""
    __tablename__ = "planetary_aspects"
    
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    planet1_id = Column(Integer, nullable=False)
    planet2_id = Column(Integer, nullable=False)
    aspect_type = Column(String, nullable=False)  # Conjunction, Opposition, Trine, etc.
    aspect_angle = Column(Float, nullable=False)  # Ideal angle of the aspect
    actual_angle = Column(Float, nullable=False)  # Actual angle between planets
    orb = Column(Float, nullable=False)  # Deviation from exact aspect
    is_applying = Column(Boolean, nullable=False)  # True if aspect is getting closer to exact
    
    # Create a composite index for efficient time-based queries
    __table_args__ = (
        Index('idx_aspects_time_planets', 'timestamp', 'planet1_id', 'planet2_id'),
    )
    
    def __repr__(self):
        return f"<PlanetaryAspect(timestamp='{self.timestamp}', aspect='{self.aspect_type}', planets={self.planet1_id}-{self.planet2_id})>"


class MarketPrediction(Base):
    """Model for storing market predictions generated by the system"""
    __tablename__ = "market_predictions"
    
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)  # When the prediction was made
    target_date = Column(DateTime, nullable=False, index=True)  # Date the prediction is for
    symbol = Column(String, nullable=False, index=True)
    prediction_value = Column(Float, nullable=False)  # Predicted value/direction
    confidence = Column(Float, nullable=False)  # Confidence level (0-1)
    model_version = Column(String, nullable=False)  # Version of the model used
    
    # Create a composite index for efficient querying
    __table_args__ = (
        Index('idx_predictions_target_symbol', 'target_date', 'symbol'),
    )
    
    def __repr__(self):
        return f"<MarketPrediction(target_date='{self.target_date}', symbol='{self.symbol}', prediction={self.prediction_value})>"